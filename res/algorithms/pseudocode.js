var pseudoCodeJson = {
    "SelectionSort": [
        "A: Array of Integers to sort",
        "N: Length of array to sort",
        "<br>",
        "Method selectionSort Begin",
        "&nbsp;&nbsp;&nbsp;for i:=0 to N-2 do",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min:=i",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for j:=i+1 to N-1 do",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if A[j]&lt;A[min] then",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min:=j",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fi",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;od",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(A, i, min)",
        "&nbsp;&nbsp;&nbsp;od",
        "End"
    ],
    "QuickSort": [
        "A: Array of Integers to sort",
        "L: Left index of partition",
        "R: Right index of partition",
        "<br>",
        "Method quickSort Begin",
        "&nbsp;&nbsp;&nbsp;if R&gt;L then",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pivot:=partition(A, L, R)",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quickSort(A, L, p-1)",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quickSort(A, p+1, R)",
        "&nbsp;&nbsp;&nbsp;fi",
        "End",
        "<br>",
        "Method partition(A, L, R) Begin",
        "&nbsp;&nbsp;&nbsp;p:=A[R]",
        "&nbsp;&nbsp;&nbsp;pL:=L",
        "&nbsp;&nbsp;&nbsp;pR:=R",
        "&nbsp;&nbsp;&nbsp;while pL&lt;pR do",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while A[pL]&lt;p do",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pL:=pL+1",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;od",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while a[pR]&gt;=p and pR&gt;L do",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pR:=pR-1",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;od",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if pL&lt;pR then",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(A, pL, pR)",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fi",
        "&nbsp;&nbsp;&nbsp;od",
        "&nbsp;&nbsp;&nbsp;swap(A, pL, R)",
        "&nbsp;&nbsp;&nbsp;return pL",
        "End"
    ],
    "SequentialSearch": [
        "A: Array of Integers containing key",
        "N: Length of array",
        "key: key to search for",
        "<br>",
        "Method sequentialSearch Begin",
        "&nbsp;&nbsp;&nbsp;for i:=0 to N-1 do",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if A[i]=key then",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return i",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fi",
        "&nbsp;&nbsp;&nbsp;od",
        "&nbsp;&nbsp;&nbsp;return -1",
        "End"
    ],
    "BinarySearch": [
        "A: Array of sorted Integers containing key",
        "N: Length of array",
        "key: key to search for",
        "L: leftmost item in array",
        "R: rightmost item in array",
        "<br>",
        "Method binarySearch(A, key, L, R) Begin",
        "&nbsp;&nbsp;&nbsp;if R&lt;L then",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -1",
        "&nbsp;&nbsp;&nbsp;fi",
        "&nbsp;&nbsp;&nbsp;i:=(R+L)/2",
        "&nbsp;&nbsp;&nbsp;if key=A[i] then",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return i",
        "&nbsp;&nbsp;&nbsp;else if key&gt;A[i] then",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return binarySearch(A, key, i+1, R)",
        "&nbsp;&nbsp;&nbsp;else",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return binarySearch(A, key, L, i-1)",
        "&nbsp;&nbsp;&nbsp;fi",
        "End"
    ],
    "PackageWrapping": [
        "P: Array of points",
        "N: Length of Array",
        "k: Number of points in convex hull",
        "min: Index of point with min angle",
        "a: Previous min angle",
        "<br>",
        "Method packageWrap Begin",
        "&nbsp;&nbsp;&nbsp;min:=findAnchorPoint(P)",
        "&nbsp;&nbsp;&nbsp;k:=0",
        "&nbsp;&nbsp;&nbsp;a:=0.0",
        "&nbsp;&nbsp;&nbsp;P[N]:=P[min]",
        "&nbsp;&nbsp;&nbsp;while min != N do",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(P, min, k)",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min:=findMinAngle(P,N,k,a)",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a:=angle(P[k],P[min])",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k:=k+1",
        "&nbsp;&nbsp;&nbsp;od",
        "&nbsp;&nbsp;&nbsp;return k",
        "End",
        "<br>",
        "Method findMinAngle(P,N,k,a) Begin",
        "&nbsp;&nbsp;&nbsp;min:=N",
        "&nbsp;&nbsp;&nbsp;for i:=k+1 to N-1 do",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if angle(P[k],P[i])&gt;=a and angle(P[k],P[i])&lt;angle(P[k],P[min]) then",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min:=i",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fi",
        "&nbsp;&nbsp;&nbsp;od",
        "&nbsp;&nbsp;&nbsp;return min",
        "End"
    ],
    "GrahamsScan": [
        "P: Array of points",
        "hull: Array of points on hull",
        "N: Length of Array",
        "anchor: point with lowest y value",
        "<br>",
        "Method grahamsScan Begin",
        "&nbsp;&nbsp;&nbsp;anchor:=findLowestPoint(P)",
        "&nbsp;&nbsp;&nbsp;sortedP:=sortByAngleFromAnchor(P, anchor)",
        "&nbsp;&nbsp;&nbsp;hull.add(anchor)",
        "&nbsp;&nbsp;&nbsp;hull.add(sortedP[1])",
        "&nbsp;&nbsp;&nbsp;for i:=0 to N-1 do",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while direction(hull[len(hull)-2], hull[len(hull)-1], sortedP[i])&lt;=0 do",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hull.remove(len(hull)-1)",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if len(hull)&lt;2 then",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fi",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;od",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hull.add(sortedP[i])",
        "&nbsp;&nbsp;&nbsp;od",
        "&nbsp;&nbsp;&nbsp;return hull",
        "End",
        "<br>",
        "Method direction(p1, p2, p3) Begin",
        "&nbsp;&nbsp;&nbsp;return (p2[0]-p1[0])*(p3[1]-p1[1])-(p2[1]-p1[1])*(p3[0]-p1[0])",
        "End"
    ],
    "BisectionMethod": [
        "x0, x1: Initial points with opposite signs",
        "f: Function",
        "m: Midpoint between x1, x1",
        "flag: Check for stopping criteria",
        "n: Number of iterations",
        "MAX: Maximum number of iterations",
        "<br>",
        "Method bisectionMethod Begin",
        "&nbsp;&nbsp;&nbsp;if (f(x0)*f(x1))&gt;0 then",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return error",
        "&nbsp;&nbsp;&nbsp;fi",
        "&nbsp;&nbsp;&nbsp;while flag=true and n&lt;MAX do",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n:=n+1",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m:=(x0+x1)/2",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (f(m)*f(x0))&lt;0 then",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x1:=m",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x0:=m",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fi",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag:= not (close(f(m),0) or close(x0,x1))",
        "&nbsp;&nbsp;&nbsp;od",
        "&nbsp;&nbsp;&nbsp;return m",
        "End"
    ],
    "NewtonsMethod": [
        "x, dx: Initial point and its derivative ",
        "f: Function",
        "df: Derivative of f",
        "flag: Check for stopping criteria",
        "n: Number of iterations",
        "MAX: Maximum number of iterations",
        "<br>",
        "Method newtonsMethod Begin",
        "&nbsp;&nbsp;&nbsp;while flag=true and n&lt;MAX do",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n:=n+1",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dx:=df(x)",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x:=x-(f(x)/dx)",
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag:= not close(f(x0),0)",
        "&nbsp;&nbsp;&nbsp;od",
        "&nbsp;&nbsp;&nbsp;return x",
        "End"
    ]
}